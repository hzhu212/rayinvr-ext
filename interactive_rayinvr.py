"""
Plot the data generated by rayinvr-matlab(plotdata.rayinvr.mat) with Python-plotly.
This will create html files that contain interactive plots. You can open them
with your web browser.
"""

import os
import argparse
import numpy as np
from scipy.io import loadmat

from plotly import offline
import plotly.graph_objs as go


MAT_FILE_NAME = 'plotdata.rayinvr.mat'
COLORS = [
    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2',
    '#7f7f7f', '#bcbd22', '#17becf',
    'plum', 'powderblue', 'purple', 'red', 'rosybrown', 'royalblue', 'saddlebrown',
    'salmon', 'sandybrown', 'seagreen', 'olive', 'olivedrab', 'orange', 'orangered',
    'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise',]


# parse command line Arguments
# ------------------------------------------------------------------------------
parser = argparse.ArgumentParser(prog='python interactive_rayinvr.py')
parser.add_argument('working_dir', type=str, help='the directory that contains plot-data generated by rayinvr-matlab.')
args = parser.parse_args()
working_dir = args.working_dir.strip()

# check parameter `working_dir`
if not os.path.isdir(working_dir):
    print('Invalid working directory: path not exists.')
    exit()

# check the existence of .mat file
mat_file = os.path.join(working_dir, MAT_FILE_NAME)
if not os.path.isfile(mat_file):
    print('Invalid working directory: file "{}" does not exist.'.format(MAT_FILE_NAME))
    exit()
# ------------------------------------------------------------------------------


def plot_model(data, label):
    """plot v.in model"""
    res = []
    opts = {
        'line': {
            'color': 'black',
            'width': 1,
            'dash': 'dash',
        },
        'hoverinfo': 'skip',
    }
    sl = {'layer': True, 'block': True}
    for xy, lb in zip(data, label):
        x, y = xy[0,:], xy[1,:]
        k = 'layer' if 'layer' in lb else 'block'
        line = go.Scatter(x=x, y=y, mode='lines', name=lb, legendgroup=lb, showlegend=sl[k], **opts)
        sl[k] = False
        res.append(line)
    return res

def plot_ray(data, label):
    """plot ray tracing overlaying on model"""
    res = []
    opts = {
        'line': {'width': 1, },
        'hoverinfo': 'x+y',
        }
    sl = {}
    for xy, lb in zip(data, label):
        x, y = xy[0,:], xy[1,:]
        rg = lb.split('/')[1]
        rg_idx = ray_groups.index(rg)
        opts['line']['color'] = COLORS[rg_idx % len(COLORS)]
        opts['line']['dash'] = 'dash' if '/s' in lb else 'solid'
        if sl.get(rg) is None:
            sl[rg] = True
        else:
            sl[rg] = False
        line = go.Scatter(x=x, y=y, mode='lines', name=rg, legendgroup=rg, showlegend=sl[rg], **opts)
        res.append(line)
    return res

def plot_obsv(data, label):
    """plot observed travel time"""
    res = []
    opts = {
        'marker': {'symbol': 'square-open', 'size': 4, 'opacity': 0.7},
        'error_y': {'type': 'constant', 'value': 0.025, 'thickness': 1, 'width': 1},
        'hoverinfo': 'x+y',
        }
    sl = {}
    for xy, lb in zip(data, label):
        x, y = xy[0,:], xy[1,:]
        rg = lb.split('/')[2]
        rg_idx = ray_groups.index(rg)
        opts['marker']['color'] = COLORS[rg_idx % len(COLORS)]
        opts['error_y']['color'] = COLORS[rg_idx % len(COLORS)]
        if sl.get(rg) is None:
            sl[rg] = True
        else:
            sl[rg] = False
        line = go.Scatter(x=x, y=y, mode='markers', name=rg, legendgroup=rg, showlegend=False, **opts)
        res.append(line)
    return res

def plot_calc(data, label):
    """plot calculated travel time"""
    res = []
    opts = {
        'line': {'width': 2, 'color': 'red'},
        'hoverinfo': 'x+y',
        }
    sl = {}
    for xy, lb in zip(data, label):
        x, y = xy[0,:], xy[1,:]
        rg = lb.split('/')[2]
        rg_idx = ray_groups.index(rg)
        opts['line']['color'] = COLORS[rg_idx % len(COLORS)]
        if sl.get(rg) is None:
            sl[rg] = True
        else:
            sl[rg] = False
        line = go.Scatter(x=x, y=y, mode='lines', name=rg, legendgroup=rg, showlegend=sl[rg], **opts)
        res.append(line)
    return res


# extract data from .mat file
# 'data' is the only user-defined element of .mat file, which is a matlab cell array.
# each element of 'data'(except the last one) is a 2*m array, containing the xdata and ydata of a line in matlab figure.
# the last element of 'data' is a string split by '|', containing labels for all lines mentioned above.
# All the labels are in following forms:
#     model/layer: line of model layer
#     model/block: line of model block boundary(vertical)
#     ray/<xshot>-<ray_code>/[p|s|ps]: line of a ray taking off from shot 'xshot'
#         and with ray code 'ray_code'. 'xshot' is a '%.4f' pattern float and 'ray_code'
#         is a '%.1f' pattern float. The last part indicate whether the ray is
#         P wave or S wave or unknown
#     time/observe/<xshot>-<ray_code>: line of observed travel time. The meaning
#     of '<xshot>-<ray_code>' is the same as above
#     time/calculate/<xshot>-<ray_code>: line of calculated travel time.

m = loadmat(mat_file, squeeze_me=True)

data = m['data']
label = data[-1].split('|')
data = np.delete(data, -1)
label = np.array(label)

# sort data by label name
idx = label.argsort()
data = np.array(data)[idx]
label = label[idx]

# remove empty data
empty_idx = np.array([True if a.size==0 else False for a in data])
data = data[~empty_idx]
label = label[~empty_idx]

# split data into following parts: model, ray, observed time, calculated time
plt2_idx = np.array([True if s.startswith('time') else False for s in label])
plt1_idx = ~plt2_idx
plt1_data = data[plt1_idx]
plt1_label = label[plt1_idx]
plt2_data = data[plt2_idx]
plt2_label = label[plt2_idx]

# get model data and ray data
model_idx = np.array([True if 'model' in s else False for s in plt1_label])
ray_idx = ~model_idx
model_data = plt1_data[model_idx]
model_label = plt1_label[model_idx]
ray_data = plt1_data[ray_idx]
ray_label = plt1_label[ray_idx]
# ray_groups = list(set([s.split('/')[1] for s in ray_label]))

# get observed time and calculated time data
obsv_idx = np.array([True if 'observe' in s else False for s in plt2_label])
calc_idx = ~obsv_idx
obsv_data = plt2_data[obsv_idx]
obsv_label = plt2_label[obsv_idx]
calc_data = plt2_data[calc_idx]
calc_label = plt2_label[calc_idx]
ray_groups = list(set([s.split('/')[2] for s in obsv_label]))

# plot data
line_model = plot_model(model_data, model_label)
line_ray = plot_ray(ray_data, ray_label)
line_obsv = plot_obsv(obsv_data, obsv_label)
line_calc = plot_calc(calc_data, calc_label)

# settings
layout_opts_base = {
    'title': 'Rayinvr Plot',
    'hovermode': 'closest',
    'hoverdistance': 10, 'spikedistance': 10,
    'xaxis': {
        'color': 'black', 'showline': True, 'linecolor': 'black',
        'mirror': 'ticks', 'spikethickness': 1, 'title': 'X (km)'},
    'yaxis': {
        'color': 'black', 'showline': True, 'linecolor': 'black',
        'mirror': 'ticks', 'spikethickness': 1, 'autorange': 'reversed'},
}

layout_opts1 = layout_opts_base.copy()
layout_opts1['title'] = 'Ray Tracing'
layout_opts1['yaxis']['title'] = 'Depth (km)'
layout1 = go.Layout(**layout_opts1)

layout_opts2 = layout_opts_base.copy()
layout_opts2['title'] = 'Travel Time'
layout_opts1['yaxis']['title'] = 'Reduced Travel Time (s)'
layout2 = go.Layout(**layout_opts2)

fig1 = go.Figure(data=line_model+line_ray, layout=layout1)
fig2 = go.Figure(data=line_obsv+line_calc, layout=layout2)
offline.plot(fig1, filename=os.path.join(working_dir, 'rayinvr_ray.html'))
offline.plot(fig2, filename=os.path.join(working_dir, 'rayinvr_time.html'))
