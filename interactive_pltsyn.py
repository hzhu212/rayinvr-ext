"""
Plot the data generated by pltsyn-matlab(plotdata.pltsyn.mat) with Python-plotly.
This will create html files that contain interactive plots. You can open them
with your web browser.
"""

import os
import argparse
import numpy as np
from scipy.io import loadmat

from plotly import offline
from plotly import tools
import plotly.graph_objs as go


MAT_FILE_NAME = 'plotdata.pltsyn.mat'
COLORS = [
    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2',
    '#7f7f7f', '#bcbd22', '#17becf',
    'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown',
    'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'olive',
    'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen',
    'paleturquoise',]


# parse command line Arguments
# ------------------------------------------------------------------------------
parser = argparse.ArgumentParser(prog='python interactive_pltsyn.py')
parser.add_argument('working_dir', type=str, help='the directory that contains plot-data generated by pltsyn-matlab.')
args = parser.parse_args()
working_dir = args.working_dir.strip()

# check parameter `working_dir`
if not os.path.isdir(working_dir):
    print('Invalid working directory: path not exists.')
    exit()

# check the existence of .mat file
mat_file = os.path.join(working_dir, MAT_FILE_NAME)
if not os.path.isfile(mat_file):
    print('Invalid working directory: file "{}" does not exist.'.format(MAT_FILE_NAME))
    exit()
# ------------------------------------------------------------------------------


def plot_data(data, labels, xtraces):
    all_labels = sorted(list(set(labels.tolist())))

    plot_opts = {
        'line': {'width': 1,},
        'hoverinfo': 'x+y',
        }

    curves = []
    legend_shown = {}
    for xy, label in zip(data, labels):
        x, y = xy[0,:], xy[1,:]
        label_idx = all_labels.index(label)
        plot_opts['line']['color'] = COLORS[label_idx % len(COLORS)]
        if label not in legend_shown:
            legend_shown[label] = True
        else:
            legend_shown[label] = False
        curve = go.Scatter(
            x=x, y=y, mode='lines', name=label, legendgroup=label,
            showlegend=legend_shown[label], **plot_opts)
        curves.append(curve)

    xmin, xmax = min(xtraces), max(xtraces)
    y0 = data[0][1,:]
    ymin, ymax = min(y0), max(y0)
    layout = go.Layout(
        hovermode='closest',
        hoverdistance=10,
        spikedistance=10,
        xaxis=dict(
            title='Distance (km)',
            side='top',
            showline=True,
            autorange=False,
            range=[xmin, xmax],
            ),
        yaxis=dict(
            title='Time (s)',
            showline=True,
            showgrid=True,
            autorange=False,
            range=[ymax, ymin],
            )
        )

    fig = go.Figure(data=curves, layout=layout)
    return fig


def plot_data_autoscale(data, labels, xtraces):
    all_labels = sorted(list(set(labels.tolist())))
    all_xtraces = sorted(list(set(xtraces.tolist())))
    ntrace = len(all_xtraces)

    fig = tools.make_subplots(rows=1, cols=ntrace, horizontal_spacing=0)

    # plot traces
    plot_opts = {
        'line': {'width': 1,},
        'hoverinfo': 'x+y',
        }
    legend_shown = {}

    for xy, label, xtrace in zip(data, labels, xtraces):
        x, y = xy[0,:], xy[1,:]
        x = x - xtrace
        label_idx = all_labels.index(label)
        trace_idx = all_xtraces.index(xtrace)
        plot_opts['line']['color'] = COLORS[label_idx % len(COLORS)]
        if label not in legend_shown:
            legend_shown[label] = True
        else:
            legend_shown[label] = False
        curve = go.Scatter(
            x=x, y=y, mode='lines', name=label, legendgroup=label,
            showlegend=legend_shown[label], **plot_opts)

        fig.append_trace(curve, 1, trace_idx+1)

    # set figure layout
    y0 = data[0][1,:]
    ymin, ymax = min(y0), max(y0)
    for i in range(ntrace):
        fig['layout']['xaxis{}'.format(i+1)].update(
            side='top',
            scaleanchor='x',
            # showspikes=True,
            # spikecolor='#eee',
            # spikethickness=1,
            # spikedash='dot',
            tickmode='array',
            tickvals=[0],
            ticktext=[all_xtraces[i]],
            autorange=True,
            showline=True,
            zeroline=False,
            showgrid=False,
        )
        fig['layout']['yaxis{}'.format(i+1)].update(
            range=[ymax, ymin],
            zeroline=True,
            showline=False,
            showticklabels=False,
        )
    fig['layout'].update(
        title='Distance (km)',
        hovermode='closest',
        hoverdistance=10,
        spikedistance=10,
        yaxis=dict(
            title='Time (s)',
            showline=True,
            showticklabels=True,
            )
        )
    return fig


# extract data from .mat file
# ------------------------------------------------------------------------------
# 'data' is the only element of .mat file, which is a matlab cell array.
# Each element of 'data'(except the last one) is a 2*m array, containing the
# xdata and ydata of a curve in matlab figure.
# The last element of 'data' is a string split by '|', containing labels for every curve.
# All the labels are in the following form:
#     <xshot>-<ray_code>: one of the curves for shot 'xshot', and with
#     ray code 'ray_code'. 'xshot' is a '%.4f' pattern float and 'ray_code'
#         is a '%.1f' pattern float.
# The second to last element of 'data' is an array containing all x positions for every curve.

m = loadmat(mat_file, squeeze_me=True)

data = m['data']
labels = np.array(data[-1].split('|'))
data = np.delete(data, -1)
xtraces = np.array(data[-1])
data = np.delete(data, -1)
data = np.array(data)
assert len(data) == len(labels)
assert len(data) == len(xtraces)

# sort data by label name and xtrace
# idx = labels.argsort()
idx = np.argsort(['{}-{:08.2f}'.format(lb, xt) for lb, xt in zip(labels, xtraces)])
data = data[idx]
xtraces = xtraces[idx]
labels = labels[idx]

# remove empty data
empty_idx = np.array([True if a.size==0 else False for a in data])
data = data[~empty_idx]
xtraces = xtraces[~empty_idx]
labels = labels[~empty_idx]

# plot data
fig1 = plot_data(data, labels, xtraces)
fig2 = plot_data_autoscale(data, labels, xtraces)

offline.plot(fig1, filename=os.path.join(working_dir, 'pltsyn.html'))
offline.plot(fig2, filename=os.path.join(working_dir, 'pltsyn_autoscale.html'))
